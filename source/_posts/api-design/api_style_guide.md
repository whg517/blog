---
title: API 设计指南
author: kevin
date: 2020-08-21 14:22:00
update: 2020-08-21 14:22:00
tags:
- api-desig
---


# 1 摘要

在当前微服务大环境之下，越来越多的项目使用 RESTful HTTP接口方位资源 。为了团队开发的友好体验，开发人员尽可能遵循一致的 REST API 设计原则就显得至关重要。

API 设计指南旨在提供一套基础规范，便于团队设计和开发出一致的 RESTful 接口。

<!-- more -->

<h1>2. 目录</h1>

# 3 引言

在各个子系统间，开发人员基本都是通过 HTTP 接口访问。尽管服务使用不同语言开发，但最终都是 HTTP 请求。为了能开发出来的产品能够支持更广泛的客户端和服务，并且不会依赖特定开发框架或者环境，就需要在 API 上有良好的设计。这些规范的目的就是尽可能所有 HTTP 客户端能轻松、一致地使用 REST API。

在吸取了社区中大量成熟的经验后，制定出了此规范。主要参考规范如下：

- [微软 REST API 规范](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md)
- [PayPal REST API 规范](https://github.com/paypal/api-standards/blob/master/api-style-guide.md)

## 3.1 推荐阅读

为了开发良好的基于 HTTP 的服务，建议理解 REST 体系结构风格的原理。如果您不熟悉 RESTful 设计，这里有一些不错的资源：

[Wikipedia 上的 REST](http://en.wikipedia.org/wiki/Representational_state_transfer) -REST背后的常见定义和核心思想概述。

[REST论文](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm) —— Roy Fielding论文中有关REST的一章，即“架构风格和基于网络的软件架构设计” 。

[RFC 7231](https://tools.ietf.org/html/rfc7231) —— HTTP / 1.1 规范。

[REST 实践](http://www.amazon.com/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829/) —— 关于REST基础的书籍。

## 4. 名词释义

### 4.1 资源

资源是 REST 中信息的关键抽象。根据 [Fielding 的论文5.2节](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2)，可以命名的任何信息都可以是资源，如：文档或图像，临时服务（例如“洛杉矶今天的天气”），其他资源的集合，非虚拟对象（例如一个人），等等。资源是到一组实体的概念性映射，而不是在任何特定时间点与该映射相对应的实体。更准确地说，资源 `R` 是随时间变化的隶属函数 `MR(t)` ，用于将时间 `t` 映射到等效的一组实体或值。集合中的值可以是资源表示和 `/` 或资源标识符。

资源也可以映射到空集，从而允许在存在任何概念之前就对该概念进行引用。

### 4.2 资源标识符

REST 使用资源标识符来标识组件之间交互中涉及的特定资源实例。命名机构（例如提供API的组织）分配了资源标识符以使其有可能引用资源，它负责维护映射随时间的语义有效性（确保成员资格函数不变）。- [菲尔丁的论文第5.2节](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2)

### 4.3 域

根据 Wikipedia 所说，[领域模型](https://en.wikipedia.org/wiki/Domain_model)是一个抽象系统，描述了知识，影响或活动领域的选定方面。这些概念包括业务中涉及的数据，以及业务针对该数据使用的规则。例如，PayPal 域模型包括诸如支付，风险，合规性，身份，客户支持等域。

### 4.4 功能

能力代表组织业务逻辑的面向业务和面向客户的视图。功能可用于组织 API 组合，作为其系统的稳定，业务驱动的视图，可由客户和经验消耗。能力的示例包括：合规性，信用，身份，零售和风险等。

功能驱动界面，而域则更粗糙，并且更接近代码和组织的结构。从服务的角度来看，能力和领域被视为正交的问题。

### 4.5 命名空间

功能推动了 API 产品组合中的服务建模和名称空间问题。命名空间是业务能力模型的一部分。名称空间的示例包括：合规性，设备，转移，信用，限制等。

命名空间应反映逻辑上将一组业务功能分组的域。域定义应反映客户对平台功能组织方式的看法。请注意，这些可能不一定反映公司的层次结构，组织或（现有）代码结构。在某些情况下，从定

#### 4.6 服务

服务提供了用于访问和操纵[资源](#resource)集合的通用 API ，无论成员资格函数的定义方式或处理请求的软件类型如何。服务是可以执行许多功能的通用软件。因此，考虑存在的不同类型的服务具有启发性。

从逻辑上讲，我们可以将公开的服务和 API 分为两类：

1. **功能 API** 是实现通用，可重用业务功能的服务所公开的公共API。
2. **特定**于**体验的 API** 建立在功能 API的基础上，并公开可能针对特定渠道的功能，或针对通用功能的特定于上下文而专门优化的功能。上下文信息可能与时间，位置，设备，通道，身份，用户，角色，授权级别等有关。

#### 4.6.1 基于功能的服务和 API

功能 API 是可重用业务功能的公共接口。*公开*暗示这些 API 仅限于供前端体验，外部使用者或来自不同域的内部使用者使用的接口。

#### 4.6.2 基于体验的服务和 API

特定于体验的服务在核心功能上提供了最少的附加业务逻辑，并且主要提供了转换和轻型编排，以根据特定体验，渠道或设备的需求量身定制交互。它们的输入/输出功能仅限于服务调用。

### 4.7 客户端，API 客户端，API 使用者

调用API请求并使用API响应的实体。

# 5. 设计原则

本节阐述指导服务设计的原则，这些服务向内部和外部开发人员，邻接，合作伙伴和关联公司公开API。服务是指与特定功能有关的功能，以API形式公开。

以下是服务的核心设计原则。

## 5.1 松耦合

**服务和消费者必须彼此松散耦合。**

耦合是指两件事之间的联系或关系。耦合程度可与依赖程度相媲美。该原则提倡服务合同的设计，并始终强调减少（*松散*）服务契约，与其实施和服务使用者之间的依赖性。

松散耦合的原理促进了服务逻辑和实现的独立设计和发展，同时仍然强调了与已经依赖该服务功能的消费者之间的基线互操作性。

该原则意味着以下几点：

- 服务契约不应公开实施细节
- 服务契约可以发展而不会影响现有消费者
- 特定域中的服务可以独立于其他域发展

### 5.2 封装形式

**域服务只能通过其他服务合同访问其不拥有的数据和功能。**

服务公开的功能包括其拥有和实现的功能和数据，以及不依赖于它的功能和数据。该原则主张，服务依赖和不拥有的任何功能或数据都只能通过服务合同来访问。

该原则意味着以下几点：

- 服务具有明确的隔离边界-在功能和数据方面明确的所有权范围
- 服务无法公开其不直接拥有的数据

### 5.3 稳定性

**服务契约必须稳定。**

服务的设计方式必须使其所暴露的契约对现有客户仍然有效。如果服务契约需要以与消费者不兼容的方式发展，则应清楚地传达这一点。

该原则意味着以下几点：

- 现有的客户服务必须在记录的时间内得到支持
- 必须以不影响现有消费者的方式引入其他功能
- 必须明确规定弃用和迁移政策以设定消费者的期望

### 5.4 可重用

**服务必须开发为可在多个上下文中被多个使用者重用。**

API 平台的主要目标是通过使用和组合服务来使应用程序能够快速，经济高效地开发。只有在为多个用例和多个使用者灵活地开发了服务契约的情况下才有可能。该原则主张服务的开发方式应使其能够被多个消费者和在多种环境中使用，其中某些环境可能会随着时间而发展。

该原则意味着以下几点：

- 服务契约不仅应针对即时环境而设计，还应具有支持和/或可扩展，以供多个消费者在不同环境中使用
- 服务合同可能需要随着时间的推移逐步发展以支持多种环境和消费者

### 5.5 基于契约

**功能和数据只能通过标准化服务契约公开。**

服务通过服务契约公开其用途和功能。服务契约包括功能方面，非功能方面（例如可用性，响应时间）和业务方面（例如每次通话费用，条款和条件）。*标准化*意味着服务合同必须符合契约设计标准。

该原则主张所有功能和数据都只能通过标准化服务契约公开。因此，服务的消费者只能通过服务契约来理解和访问功能和数据。

该原则意味着以下几点：

- 在服务合同之外无法理解或访问功能和数据
- 每条数据（例如在数据存储中管理的数据）仅由一项服务拥有

### 5.6 一致性

**服务必须遵循一组通用的规则，交互样式，词汇和共享类型。**

一组规则规定了服务的定义，以便以一致的方式公开服务。通过减少新服务使用者的学习曲线，该原理提高了API平台的易用性。

该原则意味着以下几点：

- 为服务规定了一套标准
- 服务应使用通用和共享词典中的词汇
- 兼容的交互样式，服务粒度和共享类型是实现完全互操作性和简化服务组合的关键

### 5.7 使用方便

**服务必须易于使用并在使用者（和应用程序）中组成。**

使用困难且耗时的服务会通过鼓励消费者找到访问相同功能的替代机制来降低微服务架构的优势。可组合性意味着可以轻松组合服务，因为服务合同和访问协议是一致的，并且不必对每个服务合同有不同的理解。

该原则意味着以下几点：

- 服务契约易于发现和理解
- 服务契约和协议在所有方面都是一致的，例如，标识和认证机制，错误语义，通用类型用法，分页等。
- 服务具有明确的所有权，因此消费者提供者可以就 SLA ，要求和问题与服务所有者联系
- 消费者提供者可以轻松集成，测试和部署使用此服务的消费者
- 消费者提供商可以轻松监控服务的非功能性方面

### 5.8 可外部化

**服务的设计必须使其提供的功能易于外部化。**

开发了一种服务以供可能来自另一个域或团队，另一个业务部门或另一个公司的消费者使用。在所有这些情况下，公开的功能都是相同的。更改的是访问机制或服务执行的策略，例如身份验证，授权和速率限制。由于公开的功能是相同的，因此应设计一次服务，然后通过适当的策略根据业务需求将其外部化。

该原则意味着以下几点：

- 服务接口必须从域模型及其旨在支持的预期用例中得出
- 支持的服务合同和访问（绑定）协议必须满足消费者的需求
- 服务的外部化不得要求重新实现或更改服务合同

# 6. HTTP规范

## ６.1 URL

### 6.1.1 URL 结构

人类应该能够轻松地阅读和构造URL。

在没有良好支持的客户端库的情况下，这有助于发现并简化在平台上的采用。

结构良好的URL的示例是：

```bash
https://api.contoso.com/v1.0/people/jdoe@contoso.com/inbox
```

不友善的示例URL是：

```bash
https://api.contoso.com/EWS/OData/Users('jdoe@microsoft.com')/Folders('AAMkADdiYzI1MjUzLTk4MjQtNDQ1Yy05YjJkLWNlMzMzYmIzNTY0MwAuAAAAAACzMsPHYH6HQoSwfdpDx-2bAQCXhUk6PC1dS7AERFluCgBfAAABo58UAAA=')
```

使用URL作为值会经常出现。服务可以使用URL作为值。例如，可以接受以下内容：

```bash
https://api.contoso.com/v1.0/items?url=https://resources.contoso.com/shoes/fancy
```

### 6.1.2 URL长度

在RFC 7230的 [3.1.1](https://tools.ietf.org/html/rfc7230#section-3.1.1) 节中定义的 HTTP 1.1 消息格式在请求行上没有长度限制，该长度包括目标URL。从RFC：

> HTTP并未对请求行的长度设置预定义的限制。[...]接收到比任何希望解析的URI更长的请求目标的服务器，必须以414（URI太长）状态码作为响应。

可以生成超过2083个字符的URL的服务必须为他们希望支持的客户提供便利。以下是一些确定目标客户支持的来源：

- http://stackoverflow.com/a/417184
- https://blogs.msdn.microsoft.com/ieinternals/2014/08/13/url-length-limits/

还要注意，某些技术堆栈具有严格的和可调整的URL限制，因此在设计服务时请记住这一点。

## 6.2 HTTP 方法

操作必须尽可能使用正确的HTTP方法，并且必须尊重操作幂等性。HTTP方法通常称为HTTP动词。这些术语在此上下文中是同义词，但是HTTP规范使用术语“方法”。

并非所有资源都支持这些方法，但是使用以下方法的所有资源必须符合其用法。

| 方法      | 描述                                                         | 是否幂等 |
| --------- | ------------------------------------------------------------ | -------- |
| `GET`     | 返回对象的当前值                                             | 是       |
| `PUT`     | 替换对象或创建命名对象（如果适用）                           | 是       |
| `DELETE`  | 删除物件                                                     | 是       |
| `POST`    | 根据提供的数据创建新对象，或提交命令                         | 否       |
| `HEAD`    | 返回对象的元数据以获取GET响应。支持GET方法的资源也可以支持HEAD方法 | 是       |
| `PATCH`   | 对对象应用部分更新                                           | 否       |
| `OPTIONS` | 获取有关请求的信息；有关详情，请参见下文。                   | 是       |

### 6.2.1 POST

POST 操作后，直接返回创建后的对象信息。

### 6.2.2 PATCH

IETF 已将 PATCH 标准化为用于增量更新现有对象的方法（请参阅 [RFC 5789](http://tools.ietf.org/html/rfc5789)）。符合 REST API准则的API应该支持PATCH。

### 6.2.3 通过PATCH创建资源（UPSERT语义）

允许调用者在create上指定键值的服务应支持UPSERT语义，而那些必须支持使用PATCH创建资源的服务。由于PUT被定义为内容的完全替代，因此使用PUT修改数据对客户端来说很危险。不了解（并因此忽略）资源属性的客户端在尝试更新资源时不太可能在PUT上提供它们，因此可能会无意中删除这些属性。服务可以选择支持PUT更新现有资源，但如果这样做，则它们必须使用替换语义（即，在PUT之后，资源的属性必须与请求中提供的属性匹配，包括删除未提供的任何服务器属性）。

在UPSERT语义下，服务器将对不存在资源的PATCH调用作为“创建”处理，而对现有资源的PATCH调用则作为“更新”处理。为了确保更新请求不被视为创建请求，反之亦然，客户端可以在请求中指定前置HTTP头。如果服务包含If-Match标头，则服务不得将PATCH请求视为插入；如果服务包含包含值为“ *”的If-None-Match标头，则服务不得将PATCH请求视为更新。

如果服务不支持UPSERT，则对不存在的资源的PATCH调用务必导致HTTP“ 409冲突”错误。